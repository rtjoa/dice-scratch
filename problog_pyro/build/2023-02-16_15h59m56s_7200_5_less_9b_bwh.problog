% This file was auto-generated by test.py
% Template file: bwh.problog


%%%%%% SHARED SETUP %%%%%%

num_bits(N) :- cmd_args([NAtom]), atom_number(NAtom, N).

is_var(a).
is_var(b).

not(f, t).
not(t, f).
xor(f, f, f).
xor(f, t, t).
xor(t, f, t).
xor(t, t, f).
and(f, f, f).
and(f, t, f).
and(t, f, f).
and(t, t, t).
or(f, f, f).
or(f, t, t).
or(t, f, t).
or(t, t, t).
eq(f, f, t).
eq(f, t, f).
eq(t, f, f).
eq(t, t, t).
lt(f, f, f).
lt(f, t, t).
lt(t, f, f).
lt(t, t, f).
at_least_two_of_three(f, f, f, f).
at_least_two_of_three(f, f, t, f).
at_least_two_of_three(f, t, f, f).
at_least_two_of_three(f, t, t, t).
at_least_two_of_three(t, f, f, f).
at_least_two_of_three(t, f, t, t).
at_least_two_of_three(t, t, f, t).
at_least_two_of_three(t, t, t, t).
ite(t, X, Y, X).
ite(f, X, Y, Y).

% Flips are id'd by var and a list/bitstring.
% See the BDD proofs to see how to choose probability of a particular list's
% flip to create any discrete distribution.
% Because we are generating uniforms, it's always 0.5.
0.5::flip(X, f); 0.5::flip(X, t).

ite(t, X, Y, X).
ite(f, X, Y, Y).

var_i_to_flip_bitstring(Var, 1, []) :-
    is_var(Var).

var_i_to_flip_bitstring(Var, I, [Val | L]) :-
    is_var(Var),
    I > 1,
    Im1 is I - 1,
    var_i_to_flip_bitstring(Var, Im1, L),
    bit(Var, Im1, Val).

bit(Var, I, Val) :-
    is_var(Var),
    num_bits(N),
    between(1, N, I),
    var_i_to_flip_bitstring(Var, I, L),
    flip([Var, L], Val).

%%%%%% LESS THAN %%%%%%

less_than(X, Y, 1, Res) :- bit(X, 1, X1), bit(Y, 1, Y1), lt(X1, Y1, Res).
less_than(X, Y, I, Res) :-
    bit(X, I, Xi), bit(Y, I, Yi),
    Im1 is I - 1, less_than(X, Y, Im1, SuffixLess),
    lt(Xi, Yi, HighestLess),
    eq(Xi, Yi, HighestEq),
    and(SuffixLess, HighestEq, SuffixLessAndHighestEq),
    or(HighestLess, SuffixLessAndHighestEq, Res).

less_than(X, Y, Res) :- num_bits(N), less_than(X, Y, N, Res).

query(less_than(a, b, t)).



